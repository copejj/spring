on:
    release:
        types: [published]
    workflow_dispatch: 
        inputs:
            test_tag:
                description: 'Tag to use for testing (e.g. v1.0.0-test)'
                required: false
                default: 'testing'

jobs:
    deploy-to-production:
        runs-on: ubuntu-latest
        steps:
            -   name: Execute Remote Deployment
                uses: appleboy/ssh-action@v1.2.0
                with:
                    host: ${{ vars.PROD_HOST }}
                    port: ${{ secrets.SSH_PRIVATE_PORT }}
                    username: ${{ secrets.SSH_PRIVATE_USERNAME }}
                    key: ${{ secrets.SSH_PRIVATE_KEY }}
                    # IMPORTANT: All variables used in the script must be listed here
                    envs: DB_NAME,DB_USER,DB_PASS,DB_HOST,DB_URL,API_BASE_URL,SERVER_CONTEXT_PATH,TAG_NAME
                    script: |
                        # 1. Initialization and Output
                        echo "--- Starting Deployment for $TAG_NAME ---"
                        cd ${{ vars.PROD_APP_PATH }}
                        export PGPASSWORD="$DB_PASS"
                        
                        # Specific args for psql vs pg_dump
                        PSQL_ARGS="-h $DB_HOST -U $DB_USER -d $DB_NAME -t -v ON_ERROR_STOP=1"
                        DUMP_ARGS="-h $DB_HOST -U $DB_USER -d $DB_NAME --no-subscriptions --no-publications -x -O"
                        
                        BACKUP_FILE="/tmp/pre_deploy_backup_$(date +%F_%H%M%S).sql"

                        # Define cleanup_on_failure
                        cleanup_on_failure() {
                            EXIT_CODE=$?
                            if [ $EXIT_CODE -ne 0 ]; then
                                echo "!!! ERROR DETECTED (Exit Code: $EXIT_CODE) !!!"
                                if [ -f "$BACKUP_FILE" ]; then
                                    echo "Rolling back database to $BACKUP_FILE..."
                                    # This specific sequence is required for non-superusers
                                    psql $PSQL_ARGS -c "DROP SCHEMA IF EXISTS public CASCADE; CREATE SCHEMA public; ALTER SCHEMA public OWNER TO whammy; GRANT ALL ON SCHEMA public TO public;"
                                    psql $PSQL_ARGS -f "$BACKUP_FILE"
                                    echo "Rollback complete."
                                fi
                                git checkout .
                                exit $EXIT_CODE
                            fi
                        }
                        trap cleanup_on_failure ERR

                        # 2. Database Backup
                        echo "[Step 2/8] Creating pre-deployment database backup..."
                        pg_dump $DUMP_ARGS -f "$BACKUP_FILE"
                        echo "Backup saved to $BACKUP_FILE"

                        # 3. Sync Code
                        echo "[Step 3/8] Fetching code for tag: $TAG_NAME"
                        git fetch --tags --all
                        # git checkout "$TAG_NAME"
                        git checkout -b "release-$TAG_NAME" "$TAG_NAME"

                        # 4. Database Migrations (The "No-Backslash" version)
                        echo "[Step 4/8] Running database migrations..."
                        psql $PSQL_ARGS -c "BEGIN;" -f sql/init_schema.sql -c "COMMIT;"

                        FILES=$(find sql/migrations -regextype posix-extended -regex ".*/[0-9]{8}_[0-9]+.*\.sql" | sort)
                        for FILE in $FILES; do
                            FILENAME=$(basename "$FILE")
                            ALREADY_RUN=$(psql $PSQL_ARGS -A -c "SELECT 1 FROM schema_migrations WHERE filename='$FILENAME' AND status='completed';")
                            if [ "$ALREADY_RUN" == "1" ]; then continue; fi

                            echo "Executing migration: $FILENAME"
                            
                            # Using ( ) | psql ensures the file content is read correctly without \i
                            (
                                echo "BEGIN;"
                                echo "INSERT INTO schema_migrations (filename, status) VALUES ('$FILENAME', 'pending') ON CONFLICT (filename) DO UPDATE SET status='pending', started_at=NOW(), ended_at=NULL;"
                                cat "$FILE"
                                echo "UPDATE schema_migrations SET ended_at=NOW(), status='completed' WHERE filename='$FILENAME';"
                                echo "COMMIT;"
                            ) | psql $PSQL_ARGS
                        done

                        # 5. Configuration & Build
                        echo "[Step 5/8] Configuring application properties and building..."
                        sed -i "s|<db_url>|$DB_URL|g" src/main/resources/application.properties
                        sed -i "s|<db_user>|$DB_USER|g" src/main/resources/application.properties
                        sed -i "s|<db_pass>|$DB_PASS|g" src/main/resources/application.properties
                        sed -i "s|<api_base_url>|$API_BASE_URL|g" src/main/resources/application.properties
                        sed -i "s|<server_context_path>|$SERVER_CONTEXT_PATH|g" src/main/resources/application.properties
                        mvn clean package -DskipTests

                        # 6. Deploy to Tomcat
                        echo "[Step 6/8] Deploying WAR to Tomcat..."
                        BUILD_WAR="${{ vars.PROD_APP_PATH}}/target/${{ vars.PROD_APP_NAME }}.war"
                        cp "$BUILD_WAR" "${{ vars.PROD_DEPLOY_PATH }}/${{ vars.PROD_APP_NAME }}-$TAG_NAME.war"
                        cp "$BUILD_WAR" "${{ vars.PROD_DEPLOY_PATH }}/${{ vars.PROD_DEPLOY_NAME }}.war"

                        # 7. Restart Tomcat
                        echo "[Step 7/8] Restarting Tomcat service..."
                        sudo /usr/bin/systemctl restart tomcat

                        # 8. Final Cleanup
                        echo "[Step 8/8] Cleaning up environment..."
                        git checkout .
                        mvn clean
                        rm "$BACKUP_FILE"

                        echo "--- Deployment of $TAG_NAME completed successfully! ---"
                env:
                    DB_NAME: ${{ secrets.DB_NAME }}
                    DB_USER: ${{ secrets.DB_USER }}
                    DB_PASS: ${{ secrets.DB_PASS }}
                    DB_HOST: ${{ secrets.DB_HOST }}
                    DB_URL: ${{ secrets.DB_URL }}
                    API_BASE_URL: ${{ vars.API_BASE_URL }}
                    SERVER_CONTEXT_PATH: ${{ vars.SERVER_CONTEXT_PATH }}
                    TAG_NAME: ${{ github.event.inputs.test_tag || github.event.release.tag_name }}
